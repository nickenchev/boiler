#include "core/entitycomponentsystem.h"
#include "core/components/guicomponent.h"
#include "display/renderer.h"
#include "display/systems/guisystem.h"

#include "display/imaging/imagedata.h"
#include "core/components/transformcomponent.h"
#include "../../ext/imgui/imgui.h"

using namespace Boiler;

static ImGuiKey ImGui_ImplSDL2_KeycodeToImGuiKey(int keycode);

GUISystem::GUISystem(Renderer &renderer) : System("ImGui System")
{
	expects<GUIComponent>();

	logger.log("Initializing");
	ImGui::CreateContext();

	ImGuiIO &io = ImGui::GetIO();

	int width, height;
	unsigned char *pixels = nullptr;
	io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

	ImageData imageData(pixels, Size(width, height), 4, true);
	AssetId textureId = renderer.loadTexture(imageData, TextureType::RGBA_UNORM);


	Material material;
	material.baseTexture = textureId;
	materialId = renderer.getAssetSet().materials.add(std::move(material));

	primitives.resize(renderer.getMaxFramesInFlight());
	for (AssetId &assetId : primitives)
	{
		assetId = Asset::NO_ASSET;
	}
}

GUISystem::~GUISystem()
{
	logger.log("Shutting down");
	ImGui::DestroyContext();
}

void GUISystem::mouseMove(uint32_t x, uint32_t y)
{
	ImGuiIO &io = ImGui::GetIO();
	io.AddMousePosEvent(x, y);
}

void GUISystem::mouseButton(uint8_t button, bool isDown)
{
	ImGuiIO &io = ImGui::GetIO();
	switch (button)
	{
		case 1:
		{
			io.AddMouseButtonEvent(0, isDown);
			break;
		}
		case 2:
		{
			io.AddMouseButtonEvent(2, isDown);
			break;
		}
		case 3:
		{
			io.AddMouseButtonEvent(1, isDown);
			break;
		}
	}
}

void GUISystem::mouseWheel(cgfloat x, cgfloat y)
{
	ImGuiIO &io = ImGui::GetIO();
	io.AddMouseWheelEvent(x, y);
}

void GUISystem::keyEvent(glm::int32_t key, bool isDown)
{
	ImGuiIO &io = ImGui::GetIO();
	io.AddKeyEvent(ImGui_ImplSDL2_KeycodeToImGuiKey(key), isDown);
}

void GUISystem::keyMods(uint16_t keymods)
{
    ImGuiIO& io = ImGui::GetIO();
    io.AddKeyEvent(ImGuiKey_ModCtrl, (keymods & KMOD_CTRL) != 0);
    io.AddKeyEvent(ImGuiKey_ModShift, (keymods & KMOD_SHIFT) != 0);
    io.AddKeyEvent(ImGuiKey_ModAlt, (keymods & KMOD_ALT) != 0);
    io.AddKeyEvent(ImGuiKey_ModSuper, (keymods & KMOD_GUI) != 0);
}

void GUISystem::textInput(const std::string &text)
{
    ImGuiIO& io = ImGui::GetIO();
	io.AddInputCharactersUTF8(text.c_str());
}

void GUISystem::update(Renderer &renderer, AssetSet &assetSet, const FrameInfo &frameInfo, EntityComponentSystem &ecs)
{
	ImGuiIO &io = ImGui::GetIO();
	io.DeltaTime = 1.0f/60.0f;              // TODO: set the time elapsed since the previous frame (in seconds)
	io.DisplaySize.x = renderer.getScreenSize().width;
	io.DisplaySize.y = renderer.getScreenSize().height;

	ImGui::NewFrame();

	if (getEntities().size())
	{
		for (auto &entity : getEntities())
		{
            GUIComponent &guiComp = ecs.getComponentStore().retrieve<GUIComponent>(entity);
			if (guiComp.guiRender)
			{
				guiComp.guiRender();
			}
		}
	}

	ImGui::EndFrame();
	ImGui::Render();

	// setup material group for drawing ImGui
	std::vector<MaterialGroup> groups(1);
	TransformComponent transform;
	AssetId matrixId = renderer.addMatrix(transform.getMatrix());
	groups[0].materialId = materialId;

	ImDrawData *drawData = ImGui::GetDrawData();
	std::vector<Vertex> vertices;
	std::vector<uint32_t> indices;
	uint32_t vertexBufferStart = 0;
	uint32_t indexBufferStart = 0;

	// TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
	ImVec2 clip_off = drawData->DisplayPos;
	for (int n = 0; n < drawData->CmdListsCount; n++)
	{
		const ImDrawList* cmd_list = drawData->CmdLists[n];
		const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
		const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui

		// build vertex/index buffer for draw commands
		for (ImDrawVert v : cmd_list->VtxBuffer)
		{
			ImVec4 c = ImGui::ColorConvertU32ToFloat4(v.col);
			vertices.push_back(Vertex(vec3(v.pos.x, v.pos.y, 0), vec2(v.uv.x, v.uv.y), vec4(c.x, c.y, c.z, c.w)));
		}

		for (unsigned short i : cmd_list->IdxBuffer)
		{
			indices.push_back(i);
		}

		for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
		{
			const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
			if (pcmd->UserCallback)
			{
				pcmd->UserCallback(cmd_list, pcmd);
			}
			else
			{
				// Project scissor/clipping rectangles into framebuffer space
				ImVec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y - clip_off.y);
				ImVec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w - clip_off.y);
				if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
					continue;

				// We are using scissoring to clip some objects. All low-level graphics API should support it.
				// - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
				//   (some elements visible outside their bounds) but you can fix that once everything else works!
				// - Clipping coordinates are provided in imgui coordinates space:
				//   - For a given viewport, draw_data->DisplayPos == viewport->Pos and draw_data->DisplaySize == viewport->Size
				//   - In a single viewport application, draw_data->DisplayPos == (0,0) and draw_data->DisplaySize == io.DisplaySize, but always use GetMainViewport()->Pos/Size instead of hardcoding those values.
				//   - In the interest of supporting multi-viewport applications (see 'docking' branch on github),
				//     always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
				// - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
				//TODO: MyEngineSetScissor(clip_min.x, clip_min.y, clip_max.x, clip_max.y);

				// The texture for the draw call is specified by pcmd->GetTexID().
				// The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
				//MyEngineBindTexture((MyTexture*)pcmd->GetTexID());

				uint32_t vertOffset = (pcmd->VtxOffset / sizeof(ImDrawVert)) * sizeof(Vertex); // vert offset in boiler terms
				uint32_t indexOffset = pcmd->IdxOffset;

				MaterialGroup::PrimitiveInstance inst(primitives[frameInfo.currentFrame], matrixId, vec3(0), pcmd->ElemCount,
													  vertOffset, indexOffset, vertexBufferStart, indexBufferStart);
				inst.clip.position.x = clip_min.x;
				inst.clip.position.y = clip_min.y;
				inst.clip.size.width = clip_max.x - clip_min.x;
				inst.clip.size.height = clip_max.y - clip_min.y;
				inst.shouldClip = true;

				groups[0].primitives.push_back(inst);
			}
		}
		vertexBufferStart += cmd_list->VtxBuffer.Size * sizeof(Vertex);
		indexBufferStart += cmd_list->IdxBuffer.Size * sizeof(uint32_t);
	}

	if (vertices.size())
	{
		VertexData vertexData(vertices, indices);
		if (primitives[frameInfo.currentFrame] == Asset::NO_ASSET)
		{
			AssetId bufferId = renderer.loadPrimitive(vertexData);
			primitives[frameInfo.currentFrame] = renderer.getAssetSet().primitives.add(
				Primitive(bufferId, std::move(vertexData), vec3(0, 0, 0), vec3(0, 0, 0))); // TODO: min/max should reflect actual values in vtx buffer
		}
		else
		{
			Primitive &primitive = renderer.getAssetSet().primitives.get(primitives[frameInfo.currentFrame]);
			renderer.loadPrimitive(vertexData, primitive.bufferId);
		}
		for (MaterialGroup::PrimitiveInstance &instance : groups[0].primitives)
		{
			instance.primitiveId = primitives[frameInfo.currentFrame];
		}

		renderer.render(renderer.getAssetSet(), frameInfo, groups, RenderStage::UI);
	}
}

static ImGuiKey ImGui_ImplSDL2_KeycodeToImGuiKey(int keycode)
{
    switch (keycode)
    {
        case SDLK_TAB: return ImGuiKey_Tab;
        case SDLK_LEFT: return ImGuiKey_LeftArrow;
        case SDLK_RIGHT: return ImGuiKey_RightArrow;
        case SDLK_UP: return ImGuiKey_UpArrow;
        case SDLK_DOWN: return ImGuiKey_DownArrow;
        case SDLK_PAGEUP: return ImGuiKey_PageUp;
        case SDLK_PAGEDOWN: return ImGuiKey_PageDown;
        case SDLK_HOME: return ImGuiKey_Home;
        case SDLK_END: return ImGuiKey_End;
        case SDLK_INSERT: return ImGuiKey_Insert;
        case SDLK_DELETE: return ImGuiKey_Delete;
        case SDLK_BACKSPACE: return ImGuiKey_Backspace;
        case SDLK_SPACE: return ImGuiKey_Space;
        case SDLK_RETURN: return ImGuiKey_Enter;
        case SDLK_ESCAPE: return ImGuiKey_Escape;
        case SDLK_QUOTE: return ImGuiKey_Apostrophe;
        case SDLK_COMMA: return ImGuiKey_Comma;
        case SDLK_MINUS: return ImGuiKey_Minus;
        case SDLK_PERIOD: return ImGuiKey_Period;
        case SDLK_SLASH: return ImGuiKey_Slash;
        case SDLK_SEMICOLON: return ImGuiKey_Semicolon;
        case SDLK_EQUALS: return ImGuiKey_Equal;
        case SDLK_LEFTBRACKET: return ImGuiKey_LeftBracket;
        case SDLK_BACKSLASH: return ImGuiKey_Backslash;
        case SDLK_RIGHTBRACKET: return ImGuiKey_RightBracket;
        case SDLK_BACKQUOTE: return ImGuiKey_GraveAccent;
        case SDLK_CAPSLOCK: return ImGuiKey_CapsLock;
        case SDLK_SCROLLLOCK: return ImGuiKey_ScrollLock;
        case SDLK_NUMLOCKCLEAR: return ImGuiKey_NumLock;
        case SDLK_PRINTSCREEN: return ImGuiKey_PrintScreen;
        case SDLK_PAUSE: return ImGuiKey_Pause;
        case SDLK_KP_0: return ImGuiKey_Keypad0;
        case SDLK_KP_1: return ImGuiKey_Keypad1;
        case SDLK_KP_2: return ImGuiKey_Keypad2;
        case SDLK_KP_3: return ImGuiKey_Keypad3;
        case SDLK_KP_4: return ImGuiKey_Keypad4;
        case SDLK_KP_5: return ImGuiKey_Keypad5;
        case SDLK_KP_6: return ImGuiKey_Keypad6;
        case SDLK_KP_7: return ImGuiKey_Keypad7;
        case SDLK_KP_8: return ImGuiKey_Keypad8;
        case SDLK_KP_9: return ImGuiKey_Keypad9;
        case SDLK_KP_PERIOD: return ImGuiKey_KeypadDecimal;
        case SDLK_KP_DIVIDE: return ImGuiKey_KeypadDivide;
        case SDLK_KP_MULTIPLY: return ImGuiKey_KeypadMultiply;
        case SDLK_KP_MINUS: return ImGuiKey_KeypadSubtract;
        case SDLK_KP_PLUS: return ImGuiKey_KeypadAdd;
        case SDLK_KP_ENTER: return ImGuiKey_KeypadEnter;
        case SDLK_KP_EQUALS: return ImGuiKey_KeypadEqual;
        case SDLK_LCTRL: return ImGuiKey_LeftCtrl;
        case SDLK_LSHIFT: return ImGuiKey_LeftShift;
        case SDLK_LALT: return ImGuiKey_LeftAlt;
        case SDLK_LGUI: return ImGuiKey_LeftSuper;
        case SDLK_RCTRL: return ImGuiKey_RightCtrl;
        case SDLK_RSHIFT: return ImGuiKey_RightShift;
        case SDLK_RALT: return ImGuiKey_RightAlt;
        case SDLK_RGUI: return ImGuiKey_RightSuper;
        case SDLK_APPLICATION: return ImGuiKey_Menu;
        case SDLK_0: return ImGuiKey_0;
        case SDLK_1: return ImGuiKey_1;
        case SDLK_2: return ImGuiKey_2;
        case SDLK_3: return ImGuiKey_3;
        case SDLK_4: return ImGuiKey_4;
        case SDLK_5: return ImGuiKey_5;
        case SDLK_6: return ImGuiKey_6;
        case SDLK_7: return ImGuiKey_7;
        case SDLK_8: return ImGuiKey_8;
        case SDLK_9: return ImGuiKey_9;
        case SDLK_a: return ImGuiKey_A;
        case SDLK_b: return ImGuiKey_B;
        case SDLK_c: return ImGuiKey_C;
        case SDLK_d: return ImGuiKey_D;
        case SDLK_e: return ImGuiKey_E;
        case SDLK_f: return ImGuiKey_F;
        case SDLK_g: return ImGuiKey_G;
        case SDLK_h: return ImGuiKey_H;
        case SDLK_i: return ImGuiKey_I;
        case SDLK_j: return ImGuiKey_J;
        case SDLK_k: return ImGuiKey_K;
        case SDLK_l: return ImGuiKey_L;
        case SDLK_m: return ImGuiKey_M;
        case SDLK_n: return ImGuiKey_N;
        case SDLK_o: return ImGuiKey_O;
        case SDLK_p: return ImGuiKey_P;
        case SDLK_q: return ImGuiKey_Q;
        case SDLK_r: return ImGuiKey_R;
        case SDLK_s: return ImGuiKey_S;
        case SDLK_t: return ImGuiKey_T;
        case SDLK_u: return ImGuiKey_U;
        case SDLK_v: return ImGuiKey_V;
        case SDLK_w: return ImGuiKey_W;
        case SDLK_x: return ImGuiKey_X;
        case SDLK_y: return ImGuiKey_Y;
        case SDLK_z: return ImGuiKey_Z;
        case SDLK_F1: return ImGuiKey_F1;
        case SDLK_F2: return ImGuiKey_F2;
        case SDLK_F3: return ImGuiKey_F3;
        case SDLK_F4: return ImGuiKey_F4;
        case SDLK_F5: return ImGuiKey_F5;
        case SDLK_F6: return ImGuiKey_F6;
        case SDLK_F7: return ImGuiKey_F7;
        case SDLK_F8: return ImGuiKey_F8;
        case SDLK_F9: return ImGuiKey_F9;
        case SDLK_F10: return ImGuiKey_F10;
        case SDLK_F11: return ImGuiKey_F11;
        case SDLK_F12: return ImGuiKey_F12;
    }
    return ImGuiKey_None;
}
