#include "core/componentstore.h"
#include "core/components/guicomponent.h"
#include "display/renderer.h"
#include "display/systems/guisystem.h"

#include "display/imaging/imagedata.h"
#include "core/components/transformcomponent.h"
#include "../../ext/imgui/imgui.h"

using namespace Boiler;

GUISystem::GUISystem(Renderer &renderer) : System("ImGui System")
{
	logger.log("Initializing");
	ImGui::CreateContext();

	ImGuiIO &io = ImGui::GetIO();

	int width, height;
	unsigned char *pixels = nullptr;
	io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

	ImageData imageData(pixels, Size(width, height), 4, true);
	AssetId textureId = renderer.loadTexture(imageData, TextureType::RGBA_UNORM);

	Material material;
	material.baseTexture = textureId;
	materialId = renderer.getAssetSet().materials.add(std::move(material));

	primitiveId = Asset::NO_ASSET;
}

GUISystem::~GUISystem()
{
	logger.log("Shutting down");
	ImGui::DestroyContext();
}

void GUISystem::update(Renderer &renderer, AssetSet &assetSet, const FrameInfo &frameInfo, ComponentStore &store)
{
	ImGuiIO &io = ImGui::GetIO();
	io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
	io.DisplaySize.x = renderer.getScreenSize().width;
	io.DisplaySize.y = renderer.getScreenSize().height;
	/*
	io.AddMousePosEvent(mouse_x, mouse_y);  // update mouse position
	io.AddMouseButtonEvent(0, mouse_b[0]);  // update mouse button states
	io.AddMouseButtonEvent(1, mouse_b[1]);  // update mouse button states
	*/
	ImGui::NewFrame();

	if (getEntities().size())
	{
		for (auto &entity : getEntities())
		{
			GUIComponent &guiComp = store.retrieve<GUIComponent>(entity);
			if (guiComp.guiRender)
			{
				guiComp.guiRender();
			}
		}
	}

	ImGui::ShowDemoWindow();

	ImGui::EndFrame();
	ImGui::Render();

	ImDrawData *drawData = ImGui::GetDrawData();

	// TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
	// TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
	ImVec2 clip_off = drawData->DisplayPos;
	for (int n = 0; n < drawData->CmdListsCount; n++)
	{
		const ImDrawList* cmd_list = drawData->CmdLists[n];
		const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
		const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui

		// build vertex/index buffer for draw commands
		if (primitiveId == Asset::NO_ASSET)
		{
			std::vector<Vertex> vertices;
			for (ImDrawVert v : cmd_list->VtxBuffer)
			{
				ImVec4 c = ImGui::ColorConvertU32ToFloat4(v.col);
				vertices.push_back(Vertex(vec3(v.pos.x, v.pos.y, 0), vec2(v.uv.x, v.uv.y), vec4(c.x, c.y, c.z, c.w)));
			}

			std::vector<uint32_t> indices;
			for (unsigned short i : cmd_list->IdxBuffer)
			{
				indices.push_back(i);
			}

			VertexData vertexData(vertices, indices);
			AssetId bufferId = renderer.loadPrimitive(vertexData);
			primitiveId = renderer.getAssetSet().primitives.add(Primitive(bufferId, std::move(vertexData)));
		}

		// setup material group for drawing ImGui
		std::vector<MaterialGroup> groups(1);
		TransformComponent transform;
		AssetId matrixId = renderer.addMatrix(transform.getMatrix());
		groups[0].materialId = materialId;

		for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
		{
			const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
			if (pcmd->UserCallback)
			{
				pcmd->UserCallback(cmd_list, pcmd);
			}
			else
			{
				// Project scissor/clipping rectangles into framebuffer space
				ImVec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y - clip_off.y);
				ImVec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w - clip_off.y);
				if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
					continue;

				// We are using scissoring to clip some objects. All low-level graphics API should support it.
				// - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
				//   (some elements visible outside their bounds) but you can fix that once everything else works!
				// - Clipping coordinates are provided in imgui coordinates space:
				//   - For a given viewport, draw_data->DisplayPos == viewport->Pos and draw_data->DisplaySize == viewport->Size
				//   - In a single viewport application, draw_data->DisplayPos == (0,0) and draw_data->DisplaySize == io.DisplaySize, but always use GetMainViewport()->Pos/Size instead of hardcoding those values.
				//   - In the interest of supporting multi-viewport applications (see 'docking' branch on github),
				//     always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
				// - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
				//TODO: MyEngineSetScissor(clip_min.x, clip_min.y, clip_max.x, clip_max.y);

				// The texture for the draw call is specified by pcmd->GetTexID().
				// The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
				//MyEngineBindTexture((MyTexture*)pcmd->GetTexID());

				// Render 'pcmd->ElemCount/3' indexed triangles.
				// By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.
				//MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer + pcmd->IdxOffset, vtx_buffer, pcmd->VtxOffset);

				uint32_t vertOffset = (pcmd->VtxOffset / sizeof(ImDrawVert)) * sizeof(Vertex); // vert offset in boiler terms
				//uint32_t indexOffset = (pcmd->IdxOffset / sizeof(unsigned short)) * sizeof(uint32_t); // index offset align
				uint32_t indexOffset = pcmd->IdxOffset;

				MaterialGroup::PrimitiveInstance inst(primitiveId, matrixId, vec3(0), pcmd->ElemCount, vertOffset, indexOffset);
				groups[0].primitives.push_back(inst);
			}
		}
		renderer.render(renderer.getAssetSet(), frameInfo, groups, RenderStage::UI);
	}
}
