#include "core/componentstore.h"
#include "core/components/guicomponent.h"
#include "display/renderer.h"
#include "display/systems/guisystem.h"

#include "display/imaging/imagedata.h"
#include "core/components/transformcomponent.h"
#include "../../ext/imgui/imgui.h"

using namespace Boiler;

GUISystem::GUISystem(Renderer &renderer) : System("ImGui System")
{
	logger.log("Initializing");
	ImGui::CreateContext();

	ImGui::GetStyle().Alpha = 0.2f;

	ImGuiIO &io = ImGui::GetIO();

	int width, height;
	unsigned char *pixels = nullptr;
	io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

	ImageData imageData(pixels, Size(width, height), 4, true);
	AssetId textureId = renderer.loadTexture(imageData, TextureType::RGBA_UNORM);

	Material material;
	material.baseTexture = textureId;
	materialId = renderer.getAssetSet().materials.add(std::move(material));

	primitives.resize(renderer.getMaxFramesInFlight());
	for (AssetId &assetId : primitives)
	{
		assetId = Asset::NO_ASSET;
	}
}

GUISystem::~GUISystem()
{
	logger.log("Shutting down");
	ImGui::DestroyContext();
}

void GUISystem::mouseMove(uint32_t x, uint32_t y)
{
	ImGuiIO &io = ImGui::GetIO();
	io.AddMousePosEvent(x, y);
}

void GUISystem::mouseButton(uint8_t button, bool isDown)
{
	ImGuiIO &io = ImGui::GetIO();
	io.AddMouseButtonEvent(button - 1, isDown);
}

void GUISystem::keyEvent(glm::int32_t key, bool isDown)
{
	ImGuiIO &io = ImGui::GetIO();
	io.AddKeyEvent(key, isDown);
}

void GUISystem::update(Renderer &renderer, AssetSet &assetSet, const FrameInfo &frameInfo, ComponentStore &store)
{
	ImGuiIO &io = ImGui::GetIO();
	io.DeltaTime = 1.0f/60.0f;              // TODO: set the time elapsed since the previous frame (in seconds)
	io.DisplaySize.x = renderer.getScreenSize().width;
	io.DisplaySize.y = renderer.getScreenSize().height;

	ImGui::NewFrame();

	if (getEntities().size())
	{
		for (auto &entity : getEntities())
		{
			GUIComponent &guiComp = store.retrieve<GUIComponent>(entity);
			if (guiComp.guiRender)
			{
				guiComp.guiRender();
			}
		}
	}

	ImGui::ShowDemoWindow();

	ImGui::EndFrame();
	ImGui::Render();

	// setup material group for drawing ImGui
	std::vector<MaterialGroup> groups(1);
	TransformComponent transform;
	AssetId matrixId = renderer.addMatrix(transform.getMatrix());
	groups[0].materialId = materialId;

	ImDrawData *drawData = ImGui::GetDrawData();
	std::vector<Vertex> vertices;
	std::vector<uint32_t> indices;
	uint32_t vertexBufferStart = 0;
	uint32_t indexBufferStart = 0;
	// TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
	// TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
	ImVec2 clip_off = drawData->DisplayPos;
	for (int n = 0; n < drawData->CmdListsCount; n++)
	{
		const ImDrawList* cmd_list = drawData->CmdLists[n];
		const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
		const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui

		// build vertex/index buffer for draw commands
		for (ImDrawVert v : cmd_list->VtxBuffer)
		{
			ImVec4 c = ImGui::ColorConvertU32ToFloat4(v.col);
			vertices.push_back(Vertex(vec3(v.pos.x, v.pos.y, 0), vec2(v.uv.x, v.uv.y), vec4(c.x, c.y, c.z, c.w)));
		}

		for (unsigned short i : cmd_list->IdxBuffer)
		{
			indices.push_back(i);
		}

		for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
		{
			const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
			if (pcmd->UserCallback)
			{
				pcmd->UserCallback(cmd_list, pcmd);
			}
			else
			{
				// Project scissor/clipping rectangles into framebuffer space
				ImVec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y - clip_off.y);
				ImVec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w - clip_off.y);
				if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
					continue;

				// We are using scissoring to clip some objects. All low-level graphics API should support it.
				// - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
				//   (some elements visible outside their bounds) but you can fix that once everything else works!
				// - Clipping coordinates are provided in imgui coordinates space:
				//   - For a given viewport, draw_data->DisplayPos == viewport->Pos and draw_data->DisplaySize == viewport->Size
				//   - In a single viewport application, draw_data->DisplayPos == (0,0) and draw_data->DisplaySize == io.DisplaySize, but always use GetMainViewport()->Pos/Size instead of hardcoding those values.
				//   - In the interest of supporting multi-viewport applications (see 'docking' branch on github),
				//     always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
				// - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
				//TODO: MyEngineSetScissor(clip_min.x, clip_min.y, clip_max.x, clip_max.y);

				// The texture for the draw call is specified by pcmd->GetTexID().
				// The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
				//MyEngineBindTexture((MyTexture*)pcmd->GetTexID());

				// Render 'pcmd->ElemCount/3' indexed triangles.
				// By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.
				//MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer + pcmd->IdxOffset, vtx_buffer, pcmd->VtxOffset);

				uint32_t vertOffset = (pcmd->VtxOffset / sizeof(ImDrawVert)) * sizeof(Vertex); // vert offset in boiler terms
				uint32_t indexOffset = pcmd->IdxOffset;

				MaterialGroup::PrimitiveInstance inst(primitives[frameInfo.currentFrame], matrixId, vec3(0), pcmd->ElemCount,
													  vertOffset, indexOffset, vertexBufferStart, indexBufferStart);
				inst.clip.position.x = clip_min.x;
				inst.clip.position.y = clip_min.y;
				inst.clip.size.width = clip_max.x - clip_min.y;
				inst.clip.size.height = clip_max.y - clip_min.y;
				inst.shouldClip = true;

				groups[0].primitives.push_back(inst);
			}
		}
		vertexBufferStart += vertices.size() * sizeof(Vertex);
		indexBufferStart += indices.size();
	}

	if (vertices.size())
	{
		VertexData vertexData(vertices, indices);
		if (primitives[frameInfo.currentFrame] == Asset::NO_ASSET)
		{
			AssetId bufferId = renderer.loadPrimitive(vertexData);
			primitives[frameInfo.currentFrame] = renderer.getAssetSet().primitives.add(Primitive(bufferId, std::move(vertexData)));
		}
		else
		{
			Primitive &primitive = renderer.getAssetSet().primitives.get(primitives[frameInfo.currentFrame]);
			renderer.loadPrimitive(vertexData, primitive.bufferId);
		}
		for (MaterialGroup::PrimitiveInstance &instance : groups[0].primitives)
		{
			instance.primitiveId = primitives[frameInfo.currentFrame];
		}

		renderer.render(renderer.getAssetSet(), frameInfo, groups, RenderStage::UI);
	}
}
